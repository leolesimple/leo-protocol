# LEO-001 — Spécification du protocole LEO (version 1)

## Introduction
LEO est un protocole applicatif chiffré construit au-dessus de TCP pour transférer des fichiers de manière authentifiée et intégrée. Il vise des usages simples de sauvegarde, synchronisation ponctuelle et navigation dans un espace de fichiers contrôlé. Le protocole privilégie la simplicité de mise en œuvre tout en fournissant une confidentialité et une intégrité forte entre un client et un serveur.

### Cas d'usage prévus
- Upload, download et suppression de fichiers individuels.
- Synchronisation d'un répertoire (upload récursif) côté client.
- Navigation (listing) du contenu stocké côté serveur.
- Interrogation des capacités du serveur.

### Cas d'usage non couverts
- Anonymat ou dissimulation du trafic.
- Résilience DDoS ou disponibilité face à des attaquants réseau.
- Multi-utilisateurs concurrents avec ACL granulaires (un couple login/mot de passe unique est prévu).
- Performance extrême sur des liens très haut débit (framing simple, pas de pipelining avancé).

## Modèle de sécurité (light)
- **Propriétés garanties** :
  - Confidentialité et intégrité de toutes les commandes applicatives après le handshake (AES-256-GCM).
  - Authenticité mutuelle via un secret partagé dérivé d'un échange X25519 et dérivation HKDF-SHA256.
  - Isolation du stockage : validation des chemins pour éviter les échappements hors de la racine configurée.
- **Propriétés non garanties** :
  - Anonymat ou obfuscation du trafic.
  - Protection contre les dénis de service ou l'épuisement de ressources.
  - Rotation automatique des clés longue durée ou persistance des clés au-delà d'une session.

## Vue d'ensemble
LEO encapsule des messages applicatifs chiffrés au-dessus de TCP. Le client initie toujours la connexion. Un handshake clair établit un secret partagé, puis toutes les commandes sont sérialisées JSON et chiffrées en AES-256-GCM. Deux clés de session distinctes sont dérivées : une pour le flux client→serveur, l'autre pour serveur→client.

- **Kex** : X25519.
- **Dérivation** : HKDF-SHA256 avec info `LEO-SESSION-<sessionId>`.
- **Chiffrement** : AES-256-GCM avec un nonce de 12 octets, tag de 16 octets.
- **Rôles** : un client (initie), un serveur (répond, stocke les fichiers).

## Handshake
1. Le client envoie un `CLIENT_HELLO` en clair (JSON, suivi d'un `\n`).
2. Le serveur répond en clair par `SERVER_HELLO` (JSON + `\n`).
3. Les deux pairs dérivent les clés de session puis passent en mode chiffré.

### CLIENT_HELLO
```json
{
  "type": "CLIENT_HELLO",
  "version": 1,
  "cipher": "AES-256-GCM",
  "kex": "X25519",
  "clientPublicKey": "<base64 X25519>"
}
```

### SERVER_HELLO
```json
{
  "type": "SERVER_HELLO",
  "ok": true,
  "version": 1,
  "cipher": "AES-256-GCM",
  "kex": "X25519",
  "serverPublicKey": "<base64 X25519>",
  "sessionId": "<hex 16 chars>",
  "error": "<optionnel>"
}
```

### Dérivation des clés
- Secret partagé = X25519(clientPriv, serverPub).
- HKDF-SHA256 avec info `LEO-SESSION-<sessionId>` produit 64 octets, découpés en deux clés de 32 octets :
  - `clientToServerKey`
  - `serverToClientKey`

### Diagramme de séquence
```
Client                         Serveur
  | -- CLIENT_HELLO ---------> |
  | <-------- SERVER_HELLO --- |
  | (derive keys)              | (derive keys)
  | -- AUTH (chiffré) -------> |
  | <--- AUTH_OK/ERROR (ch.) --|
  | ... commandes chiffrées ...|
```

## Framing binaire
Chaque message applicatif est sérialisé JSON (UTF-8), chiffré AES-256-GCM, puis encadré :
```
[length:4 octets big endian][nonce|ciphertext|tag]
```
- `length` : taille totale du bloc chiffré (nonce + ciphertext + tag).
- `nonce` : 12 octets générés aléatoirement côté expéditeur.
- `tag` : 16 octets (auth tag GCM) placés en fin de bloc chiffré.
- Plusieurs frames peuvent arriver concaténées ; le récepteur découpe selon `length`.

Exemple (pseudo hex) :
```
00 00 00 2a | <12o nonce> <ciphertext ...> <16o tag>
```

## Commandes applicatives
Toutes les commandes suivantes sont sérialisées JSON **avant chiffrement**. Les champs sont obligatoires sauf mention contraire.

### AUTH / AUTH_OK / AUTH_ERROR
- `AUTH` `{ "type": "AUTH", "username": string, "password": string }`
- Réponse succès : `{ "type": "AUTH_OK" }`
- Réponse erreur : `{ "type": "AUTH_ERROR", "errorCode": "AUTH_INVALID_CREDENTIALS", "error": "Invalid credentials", "message": "Identifiants invalides" }`

### PUT_BEGIN / PUT_CHUNK / PUT_END / PUT_OK
- `PUT_BEGIN` `{ "type": "PUT_BEGIN", "path": string, "size": number }`
- `PUT_CHUNK` `{ "type": "PUT_CHUNK", "path": string, "offset": number, "data": base64 }`
- `PUT_END` `{ "type": "PUT_END", "path": string }`
- Réponse : `{ "type": "PUT_OK", "path": string }`
- Scénario : BEGIN (allocation), envoi de chunks séquentiels, END déclenche `PUT_OK`.

### GET_BEGIN / GET_META / GET_CHUNK / GET_END
- `GET_BEGIN` `{ "type": "GET_BEGIN", "path": string }`
- `GET_META` `{ "type": "GET_META", "path": string, "size": number }`
- `GET_CHUNK` `{ "type": "GET_CHUNK", "path": string, "offset": number, "data": base64 }`
- `GET_END` `{ "type": "GET_END", "path": string }`
- Scénario succès : BEGIN → META → CHUNK* → END.
- Échec typique : fichier manquant → `ERROR` avec `FILE_NOT_FOUND`.

### LIST / LIST_RESULT
- `LIST` `{ "type": "LIST", "path": string }`
- `LIST_RESULT` `{ "type": "LIST_RESULT", "path": string, "items": [{ "name": string, "type": "file"|"dir", "size"?: number }] }`

### DEL / DEL_OK / DEL_ERROR
- `DEL` `{ "type": "DEL", "path": string }`
- `DEL_OK` `{ "type": "DEL_OK", "path": string }`
- `DEL_ERROR` `{ "type": "DEL_ERROR", "path": string, "errorCode": string, "message": string }`
- Contrainte : le chemin doit rester dans la racine de stockage et viser un fichier (pas de dossier).
- Échecs typiques : fichier manquant (`FILE_NOT_FOUND`), chemin invalide (`INVALID_PATH`), permission (`PERMISSION_DENIED`).

### INFO / INFO_RESULT
- `INFO` `{ "type": "INFO" }`
- `INFO_RESULT` `{ "type": "INFO_RESULT", "version": string, "protocolVersion": number, "capabilities": string[], "storageRoot"?: string, "maxUploadSize"?: number }`
- Permet de découvrir la version applicative, la version de protocole (v1) et la liste des commandes supportées (`["AUTH","PUT","GET","LIST","DEL","INFO","BYE"]`).

### BYE
- `{ "type": "BYE" }` : demande de fermeture propre de la session.

### ERROR
- `{ "type": "ERROR", "errorCode": string, "error": string, "message": string, "details"?: string }`
- Utilisé pour signaler les erreurs génériques ou inattendues.

## Gestion des erreurs
Les erreurs sont normalisées avec un `errorCode` stable et un message humain lisible. Codes principaux :
- `AUTH_INVALID_CREDENTIALS`
- `UNAUTHORIZED`
- `INVALID_MESSAGE`
- `INVALID_COMMAND`
- `INVALID_PATH`
- `FILE_NOT_FOUND`
- `NOT_A_FILE`
- `PERMISSION_DENIED`
- `UPLOAD_NOT_INITIALIZED`
- `IO_ERROR`
- `INTERNAL_ERROR`

`details` peut contenir une information supplémentaire de debug (optionnel). Les commandes spécifiques peuvent aussi renvoyer leurs propres enveloppes d'erreur (ex: `DEL_ERROR`).

## Exemples de scénarios

### AUTH + PUT + BYE
1. Handshake (CLIENT_HELLO / SERVER_HELLO).
2. `AUTH` → `AUTH_OK`.
3. `PUT_BEGIN { path:"docs/report.pdf", size: 10240 }`.
4. Plusieurs `PUT_CHUNK` base64.
5. `PUT_END` → `PUT_OK`.
6. `BYE` puis fermeture de la connexion.

### GET
1. Handshake + `AUTH`.
2. `GET_BEGIN { path:"docs/report.pdf" }`.
3. `GET_META` renvoie la taille, puis flux de `GET_CHUNK`.
4. `GET_END` clôt le transfert.

### LIST
1. Handshake + `AUTH`.
2. `LIST { path:"docs" }`.
3. `LIST_RESULT` renvoie les entrées (nom, type, taille si fichier).

### DEL
1. Handshake + `AUTH`.
2. `DEL { path:"docs/obsolete.txt" }`.
3. Réponse `DEL_OK` si suppression réussie ou `DEL_ERROR` avec `errorCode` sinon.

### INFO
1. Handshake + `AUTH`.
2. `INFO {}`.
3. `INFO_RESULT` avec version, protocole, capacités et racine de stockage.

## Compatibilité
- Les nouveaux champs d'erreur (`errorCode`, `message`) sont ajoutés de façon rétrocompatible : le champ `error` reste présent pour les clients existants.
- Les commandes historiques (AUTH, PUT, GET, LIST, BYE) restent inchangées.
- Les nouvelles commandes `DEL` et `INFO` sont optionnelles pour les anciens clients ; les serveurs qui ne les comprennent doivent répondre `ERROR` avec `INVALID_COMMAND`.
- Le framing, le handshake et la crypto sont identiques à la version précédente.
